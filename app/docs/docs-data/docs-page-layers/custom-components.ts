import { ComponentLayer } from "@/components/ui/ui-builder/types";

export const CUSTOM_COMPONENTS_LAYER = {
    "id": "custom-components",
    "type": "div",
    "name": "Custom Components",
    "props": {
      "className": "h-full bg-background px-4 flex flex-col gap-6 min-h-screen",
      "data-group": "component-system"
    },
    "children": [
      {
        "type": "span",
        "children": "Creating Custom Components",
        "id": "custom-components-title",
        "name": "Text",
        "props": {
          "className": "text-4xl"
        }
      },
      {
        "id": "custom-components-intro",
        "type": "Markdown",
        "name": "Markdown",
        "props": {},
        "children": "Learn how to integrate your existing React components into UI Builder. This focused guide shows you how to take any React component and make it available in the visual editor."
      },
      {
        "id": "custom-components-content",
        "type": "Markdown",
        "name": "Markdown",
        "props": {},
        "children": "## The Process: From React Component to UI Builder\n\nIntegrating a custom component into UI Builder is a straightforward 3-step process:\n\n1. **Your React Component** - Works as-is, no modifications needed\n2. **Create Component Definition** - Define schema and configuration\n3. **Add to Registry** - Include in your componentRegistry prop\n\n## Step 1: Your Existing React Component\n\nUI Builder works with your existing React components without any modifications. Here's a realistic example:\n\n```tsx\n// components/ui/user-card.tsx\ninterface UserCardProps {\n  className?: string;\n  children?: React.ReactNode;\n  name: string;\n  email: string;\n  role: 'admin' | 'user' | 'viewer';\n  avatarUrl?: string;\n  isOnline?: boolean;\n}\n\nexport function UserCard({ \n  className,\n  children,\n  name,\n  email,\n  role,\n  avatarUrl,\n  isOnline = false\n}: UserCardProps) {\n  return (\n    <div className={cn(\"border rounded-lg p-4 bg-card\", className)}>\n      <div className=\"flex items-center gap-3\">\n        {avatarUrl && (\n          <img \n            src={avatarUrl} \n            alt={name}\n            className=\"w-10 h-10 rounded-full\" \n          />\n        )}\n        <div className=\"flex-1\">\n          <div className=\"flex items-center gap-2\">\n            <h3 className=\"font-semibold\">{name}</h3>\n            {isOnline && (\n              <div className=\"w-2 h-2 bg-green-500 rounded-full\" />\n            )}\n          </div>\n          <p className=\"text-sm text-muted-foreground\">{email}</p>\n          <span className={cn(\n            \"text-xs px-2 py-1 rounded\",\n            role === 'admin' ? 'bg-red-100 text-red-700' :\n            role === 'user' ? 'bg-blue-100 text-blue-700' :\n            'bg-gray-100 text-gray-700'\n          )}>\n            {role}\n          </span>\n        </div>\n      </div>\n      {children && (\n        <div className=\"mt-3 pt-3 border-t\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**Key Requirements for UI Builder Components:**\n- **Accept `className`**: For styling integration\n- **Accept `children`**: For content composition (optional)\n- **Use TypeScript interfaces**: Clear prop definitions help with schema creation\n- **Follow your design system**: Keep consistent with existing patterns\n\n## Step 2: Create the Component Definition\n\nNext, create a definition that tells UI Builder how to work with your component:\n\n```tsx\nimport { z } from 'zod';\nimport { UserCard } from '@/components/ui/user-card';\nimport { classNameFieldOverrides, childrenFieldOverrides } from '@/lib/ui-builder/registry/form-field-overrides';\n\nconst userCardDefinition = {\n  // The React component itself\n  component: UserCard,\n  \n  // Zod schema defining props for the auto-generated form\n  schema: z.object({\n    className: z.string().optional(),\n    children: z.any().optional(),\n    name: z.string().default('John Doe'),\n    email: z.string().default('john@example.com'),\n    role: z.enum(['admin', 'user', 'viewer']).default('user'),\n    avatarUrl: z.string().optional(),\n    isOnline: z.boolean().default(false),\n  }),\n  \n  // Import path for code generation\n  from: '@/components/ui/user-card',\n  \n  // Custom form field overrides (optional)\n  fieldOverrides: {\n    className: (layer) => classNameFieldOverrides(layer),\n    children: (layer) => childrenFieldOverrides(layer),\n    email: (layer) => ({\n      inputProps: {\n        type: 'email',\n        placeholder: 'user@example.com'\n      }\n    }),\n    avatarUrl: (layer) => ({\n      inputProps: {\n        type: 'url',\n        placeholder: 'https://example.com/avatar.jpg'\n      }\n    })\n  }\n};\n```\n\n**Schema Design Tips:**\n- Use `.default()` values for better user experience\n- Use `z.coerce.number()` for numeric inputs (handles string conversion)\n- Use `z.coerce.date()` for date inputs (handles string conversion)\n- Always include `className` and `children` props for flexibility\n- Use clear enum values that make sense to non-technical users\n\n## Step 3: Add to Your Component Registry\n\nInclude your definition in the componentRegistry prop:\n\n```tsx\nimport UIBuilder from '@/components/ui/ui-builder';\nimport { primitiveComponentDefinitions } from '@/lib/ui-builder/registry/primitive-component-definitions';\nimport { complexComponentDefinitions } from '@/lib/ui-builder/registry/complex-component-definitions';\n\nconst myComponentRegistry = {\n  // Include pre-built components\n  ...primitiveComponentDefinitions, // div, span, img, etc.\n  ...complexComponentDefinitions,   // Button, Badge, Card, etc.\n  \n  // Add your custom components\n  UserCard: userCardDefinition,\n  // Add more custom components...\n};\n\nexport function App() {\n  return (\n    <UIBuilder componentRegistry={myComponentRegistry} />\n  );\n}\n```\n\nThat's it! Your `UserCard` component is now available in the UI Builder editor.\n\n## Advanced Features\n\n### Automatic Variable Bindings\n\nMake components automatically bind to system data when added to the canvas:\n\n```tsx\nUserCard: {\n  component: UserCard,\n  schema: z.object({...}),\n  from: '@/components/ui/user-card',\n  \n  // Auto-bind properties to variables when component is added\n  defaultVariableBindings: [\n    {\n      propName: 'name',\n      variableId: 'current-user-name',\n      immutable: false // Users can unbind this\n    },\n    {\n      propName: 'email', \n      variableId: 'current-user-email',\n      immutable: true // Locked for security\n    },\n    {\n      propName: 'role',\n      variableId: 'current-user-role',\n      immutable: true // Prevent role tampering\n    }\n  ]\n}\n```\n\n**Use Cases for Variable Bindings:**\n- **User profiles**: Auto-bind to current user data\n- **Multi-tenant apps**: Bind to tenant-specific branding\n- **System data**: Connect to live counters, statuses, timestamps\n- **A/B testing**: Bind to feature flag variables\n\n**Immutable Bindings**: Set `immutable: true` to prevent users from unbinding critical data like user IDs, brand colors, or security permissions.\n\n### Default Children Structure\n\nProvide default child components when users add your component:\n\n```tsx\nUserCard: {\n  component: UserCard,\n  schema: z.object({...}),\n  from: '@/components/ui/user-card',\n  \n  // Default children when component is added\n  defaultChildren: [\n    {\n      id: 'user-actions',\n      type: 'div',\n      name: 'Action Buttons',\n      props: { \n        className: 'flex gap-2 mt-2' \n      },\n      children: [\n        {\n          id: 'edit-btn',\n          type: 'Button',\n          name: 'Edit Button',\n          props: {\n            variant: 'outline',\n            size: 'sm'\n          },\n          children: 'Edit Profile'\n        },\n        {\n          id: 'message-btn', \n          type: 'Button',\n          name: 'Message Button',\n          props: {\n            variant: 'default',\n            size: 'sm'\n          },\n          children: 'Send Message'\n        }\n      ]\n    }\n  ]\n}\n```\n\n**Important**: All component types referenced in `defaultChildren` must exist in your componentRegistry (like `Button` and `div` in the example above).\n\n## Complete Example: Blog Post Card\n\nHere's a complete example showing a blog post component with all advanced features:\n\n```tsx\n// components/ui/blog-post-card.tsx\ninterface BlogPostCardProps {\n  className?: string;\n  children?: React.ReactNode;\n  title: string;\n  excerpt: string;\n  author: string;\n  publishedAt: Date;\n  readTime: number;\n  category: string;\n  featured?: boolean;\n}\n\nexport function BlogPostCard({ \n  className, \n  children, \n  title,\n  excerpt,\n  author,\n  publishedAt,\n  readTime,\n  category,\n  featured = false\n}: BlogPostCardProps) {\n  return (\n    <article className={cn(\n      \"border rounded-lg p-6 bg-card hover:shadow-md transition-shadow\",\n      featured && \"border-primary bg-primary/5\",\n      className\n    )}>\n      {featured && (\n        <div className=\"text-xs text-primary font-medium mb-2\">\n          ⭐ Featured Post\n        </div>\n      )}\n      <div className=\"text-sm text-muted-foreground mb-2\">\n        {category} • {readTime} min read\n      </div>\n      <h2 className=\"text-xl font-semibold mb-3\">{title}</h2>\n      <p className=\"text-muted-foreground mb-4\">{excerpt}</p>\n      <div className=\"flex items-center justify-between\">\n        <div className=\"text-sm\">\n          By {author} • {publishedAt.toLocaleDateString()}\n        </div>\n        {children}\n      </div>\n    </article>\n  );\n}\n\n// Component definition with all features\nconst blogPostCardDefinition = {\n  component: BlogPostCard,\n  schema: z.object({\n    className: z.string().optional(),\n    children: z.any().optional(),\n    title: z.string().default('Sample Blog Post Title'),\n    excerpt: z.string().default('A brief description of the blog post content...'),\n    author: z.string().default('John Author'),\n    publishedAt: z.coerce.date().default(new Date()),\n    readTime: z.coerce.number().default(5),\n    category: z.string().default('Technology'),\n    featured: z.boolean().default(false),\n  }),\n  from: '@/components/ui/blog-post-card',\n  fieldOverrides: {\n    className: (layer) => classNameFieldOverrides(layer),\n    children: (layer) => childrenFieldOverrides(layer),\n    excerpt: (layer) => ({\n      fieldType: 'textarea',\n      inputProps: {\n        placeholder: 'Brief post description...'\n      }\n    }),\n    publishedAt: (layer) => ({\n      fieldType: 'date'\n    })\n  },\n  defaultVariableBindings: [\n    {\n      propName: 'author',\n      variableId: 'current-author-name',\n      immutable: false\n    }\n  ],\n  defaultChildren: [\n    {\n      id: 'post-actions',\n      type: 'div',\n      name: 'Post Actions',\n      props: { className: 'flex gap-2' },\n      children: [\n        {\n          id: 'read-more',\n          type: 'Button',\n          name: 'Read More',\n          props: {\n            variant: 'outline',\n            size: 'sm'\n          },\n          children: 'Read More'\n        }\n      ]\n    }\n  ]\n};\n```\n\n## See It In Action\n\nView the [Immutable Bindings Example](/examples/editor/immutable-bindings) to see custom components with automatic variable bindings in action. This example demonstrates:\n\n- Custom components with system data bindings\n- Immutable bindings for security-sensitive data\n- Real-world component integration patterns\n\n## Testing Your Custom Components\n\nAfter adding your component to the registry:\n\n1. **Add to Canvas**: Find your component in the component panel and add it\n2. **Test Properties**: Use the properties panel to configure all props\n3. **Check Children**: Verify children support works if implemented\n4. **Test Variables**: If using variable bindings, test the binding UI\n5. **Export Code**: Use the export feature to verify generated React code\n6. **Render Test**: Test with LayerRenderer to ensure runtime rendering works\n\n## Best Practices\n\n### Component Design\n- **Keep props simple**: Complex nested objects are hard to edit visually\n- **Provide sensible defaults**: Reduce setup friction for content creators\n- **Use semantic prop names**: Make properties self-explanatory\n- **Handle edge cases**: Always provide fallbacks for optional data\n- **Follow accessibility guidelines**: Ensure components work for all users\n\n### Schema Design\n- **Use meaningful defaults**: Help users understand expected values\n- **Validate appropriately**: Don't over-constrain creative usage\n- **Group related props**: Use nested objects for logical groupings (sparingly)\n- **Provide helpful enums**: Use descriptive enum values instead of codes\n- **Consider the editing experience**: Think about how non-technical users will configure props\n\n### Variable Bindings\n- **Use immutable bindings** for system data, security info, and brand consistency\n- **Leave content editable** by not binding text props that should be customizable\n- **Provide meaningful variable names** that clearly indicate their purpose\n- **Test binding scenarios** to ensure the editing experience is smooth\n\n### Performance\n- **Minimize re-renders**: Use React.memo if your component is expensive to render\n- **Optimize images**: Handle image loading states and errors gracefully\n- **Consider bundle size**: Avoid heavy dependencies in components used in the editor\n\nWith these patterns, your custom components will provide a seamless editing experience while maintaining the flexibility and power of your existing React components."
      }
    ]
  } as const satisfies ComponentLayer; 