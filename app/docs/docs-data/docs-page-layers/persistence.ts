import { ComponentLayer } from "@/components/ui/ui-builder/types";

export const PERSISTENCE_LAYER = {
    "id": "persistence",
    "type": "div",
    "name": "State Management & Persistence",
    "props": {
      "className": "h-full bg-background px-4 flex flex-col gap-6 min-h-screen",
      "data-group": "layout-persistence"
    },
    "children": [
      {
        "type": "span",
        "children": "State Management & Persistence",
        "id": "persistence-title",
        "name": "Text",
        "props": {
          "className": "text-4xl"
        }
      },
      {
        "id": "persistence-intro",
        "type": "Markdown",
        "name": "Markdown",
        "props": {},
        "children": "Learn how UI Builder manages state and provides flexible persistence options for your layouts and variables. Save to databases, manage auto-save behavior, and handle state changes with simple, powerful APIs."
      },
      {
        "id": "persistence-content",
        "type": "Markdown",
        "name": "Markdown",
        "props": {},
        "children": "## Understanding UI Builder State\n\nUI Builder manages two main types of state:\n- **Layers**: The component hierarchy and structure\n- **Variables**: Dynamic data that can be bound to component properties\n\n## Local Storage Persistence\n\nBy default, UI Builder automatically saves state to browser local storage:\n\n```tsx\n// Default behavior - auto-saves to localStorage\n<UIBuilder componentRegistry={myComponentRegistry} />\n\n// Disable local storage persistence\n<UIBuilder \n  componentRegistry={myComponentRegistry}\n  persistLayerStore={false}\n/>\n```\n\n## Database Integration\n\nFor production applications, you'll want to save state to your database:\n\n```tsx\nimport { useState, useEffect } from 'react';\nimport UIBuilder from '@/components/ui/ui-builder';\nimport { ComponentLayer, Variable } from '@/components/ui/ui-builder/types';\n\nfunction DatabaseIntegratedBuilder({ userId }: { userId: string }) {\n  const [initialLayers, setInitialLayers] = useState<ComponentLayer[]>();\n  const [initialVariables, setInitialVariables] = useState<Variable[]>();\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Load initial state from database\n  useEffect(() => {\n    async function loadUserLayout() {\n      try {\n        const response = await fetch(`/api/layouts/${userId}`);\n        const data = await response.json();\n        \n        setInitialLayers(data.layers || []);\n        setInitialVariables(data.variables || []);\n      } catch (error) {\n        console.error('Failed to load layout:', error);\n        // Fallback to empty state\n        setInitialLayers([]);\n        setInitialVariables([]);\n      } finally {\n        setIsLoading(false);\n      }\n    }\n\n    loadUserLayout();\n  }, [userId]);\n\n  // Save layers to database\n  const handleLayersChange = async (updatedLayers: ComponentLayer[]) => {\n    try {\n      await fetch(`/api/layouts/${userId}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ layers: updatedLayers })\n      });\n    } catch (error) {\n      console.error('Failed to save layers:', error);\n    }\n  };\n\n  // Save variables to database\n  const handleVariablesChange = async (updatedVariables: Variable[]) => {\n    try {\n      await fetch(`/api/variables/${userId}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ variables: updatedVariables })\n      });\n    } catch (error) {\n      console.error('Failed to save variables:', error);\n    }\n  };\n\n  if (isLoading) {\n    return <div>Loading your layout...</div>;\n  }\n\n  return (\n    <UIBuilder\n      componentRegistry={myComponentRegistry}\n      initialLayers={initialLayers}\n      onChange={handleLayersChange}\n      initialVariables={initialVariables}\n      onVariablesChange={handleVariablesChange}\n      persistLayerStore={false} // Disable local storage since we're using database\n    />\n  );\n}\n```\n\n## Debounced Auto-Save\n\nTo avoid excessive API calls, implement debounced saving:\n\n```tsx\nimport { useCallback } from 'react';\nimport { debounce } from 'lodash';\n\nfunction AutoSaveBuilder() {\n  // Debounced save function - waits 2 seconds after last change\n  const debouncedSave = useCallback(\n    debounce(async (layers: ComponentLayer[]) => {\n      try {\n        await fetch('/api/layouts/save', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ layers })\n        });\n        console.log('Auto-saved successfully');\n      } catch (error) {\n        console.error('Auto-save failed:', error);\n      }\n    }, 2000),\n    []\n  );\n\n  const debouncedSaveVariables = useCallback(\n    debounce(async (variables: Variable[]) => {\n      try {\n        await fetch('/api/variables/save', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ variables })\n        });\n        console.log('Variables auto-saved successfully');\n      } catch (error) {\n        console.error('Variables auto-save failed:', error);\n      }\n    }, 2000),\n    []\n  );\n\n  return (\n    <UIBuilder\n      componentRegistry={myComponentRegistry}\n      onChange={debouncedSave}\n      onVariablesChange={debouncedSaveVariables}\n      persistLayerStore={false}\n    />\n  );\n}\n```\n\n## Manual Save with UI Feedback\n\nProvide users with explicit save controls:\n\n```tsx\nimport { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\n\nfunction ManualSaveBuilder() {\n  const [currentLayers, setCurrentLayers] = useState<ComponentLayer[]>([]);\n  const [currentVariables, setCurrentVariables] = useState<Variable[]>([]);\n  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n\n  const handleLayersChange = (layers: ComponentLayer[]) => {\n    setCurrentLayers(layers);\n    setHasUnsavedChanges(true);\n  };\n\n  const handleVariablesChange = (variables: Variable[]) => {\n    setCurrentVariables(variables);\n    setHasUnsavedChanges(true);\n  };\n\n  const handleSave = async () => {\n    setIsSaving(true);\n    try {\n      await Promise.all([\n        fetch('/api/layouts/save', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ layers: currentLayers })\n        }),\n        fetch('/api/variables/save', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ variables: currentVariables })\n        })\n      ]);\n      \n      setHasUnsavedChanges(false);\n      alert('Saved successfully!');\n    } catch (error) {\n      console.error('Save failed:', error);\n      alert('Save failed. Please try again.');\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Save Controls */}\n      <div className=\"flex items-center gap-2 p-4 border-b\">\n        <Button \n          onClick={handleSave}\n          disabled={!hasUnsavedChanges || isSaving}\n        >\n          {isSaving ? 'Saving...' : 'Save'}\n        </Button>\n        \n        {hasUnsavedChanges && (\n          <Badge variant=\"outline\">Unsaved Changes</Badge>\n        )}\n      </div>\n      \n      {/* Builder */}\n      <div className=\"flex-1\">\n        <UIBuilder\n          componentRegistry={myComponentRegistry}\n          onChange={handleLayersChange}\n          onVariablesChange={handleVariablesChange}\n          persistLayerStore={false}\n        />\n      </div>\n    </div>\n  );\n}\n```\n\n## Data Format\n\nUI Builder saves data in a simple, readable JSON format:\n\n```json\n{\n  \"layers\": [\n    {\n      \"id\": \"page-1\",\n      \"type\": \"div\",\n      \"name\": \"Page 1\",\n      \"props\": {\n        \"className\": \"p-4 bg-white\"\n      },\n      \"children\": [\n        {\n          \"id\": \"button-1\",\n          \"type\": \"Button\",\n          \"name\": \"Submit Button\",\n          \"props\": {\n            \"variant\": \"default\",\n            \"children\": { \"__variableRef\": \"buttonText\" }\n          },\n          \"children\": []\n        }\n      ]\n    }\n  ],\n  \"variables\": [\n    {\n      \"id\": \"buttonText\",\n      \"name\": \"Button Text\",\n      \"type\": \"string\",\n      \"defaultValue\": \"Click Me!\"\n    }\n  ]\n}\n```\n\n## API Route Examples\n\nHere are example API routes for Next.js:\n\n### Save Layout API Route\n\n```tsx\n// app/api/layouts/[userId]/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: { userId: string } }\n) {\n  try {\n    const { layers } = await request.json();\n    const { userId } = params;\n    \n    // Save to your database\n    await saveUserLayout(userId, layers);\n    \n    return NextResponse.json({ success: true });\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Failed to save layout' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: { userId: string } }\n) {\n  try {\n    const { userId } = params;\n    const layout = await getUserLayout(userId);\n    \n    return NextResponse.json(layout);\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Failed to load layout' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n### Save Variables API Route\n\n```tsx\n// app/api/variables/[userId]/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: { userId: string } }\n) {\n  try {\n    const { variables } = await request.json();\n    const { userId } = params;\n    \n    await saveUserVariables(userId, variables);\n    \n    return NextResponse.json({ success: true });\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Failed to save variables' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n## Error Handling & Recovery\n\nImplement robust error handling for persistence:\n\n```tsx\nfunction RobustBuilder() {\n  const [lastSavedState, setLastSavedState] = useState(null);\n  const [saveError, setSaveError] = useState<string | null>(null);\n\n  const handleSaveWithRetry = async (layers: ComponentLayer[], retries = 3) => {\n    for (let i = 0; i < retries; i++) {\n      try {\n        await fetch('/api/layouts/save', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ layers })\n        });\n        \n        setLastSavedState(layers);\n        setSaveError(null);\n        return;\n      } catch (error) {\n        if (i === retries - 1) {\n          setSaveError('Failed to save after multiple attempts');\n          console.error('Save failed after retries:', error);\n        } else {\n          // Wait before retry\n          await new Promise(resolve => setTimeout(resolve, 1000));\n        }\n      }\n    }\n  };\n\n  const handleRecovery = () => {\n    if (lastSavedState) {\n      // Restore to last saved state\n      window.location.reload();\n    }\n  };\n\n  return (\n    <div>\n      {saveError && (\n        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\">\n          <strong>Save Error:</strong> {saveError}\n          <Button onClick={handleRecovery} className=\"ml-2\">\n            Recover Last Saved\n          </Button>\n        </div>\n      )}\n      \n      <UIBuilder\n        componentRegistry={myComponentRegistry}\n        onChange={handleSaveWithRetry}\n        persistLayerStore={false}\n      />\n    </div>\n  );\n}\n```\n\n## Best Practices\n\n1. **Always handle save errors gracefully** - Show user feedback and provide recovery options\n2. **Use debouncing for auto-save** - Avoid overwhelming your API with requests\n3. **Validate data before saving** - Ensure the data structure is correct\n4. **Provide manual save controls** - Give users explicit control over when data is saved\n5. **Consider offline support** - Store changes locally when the network is unavailable\n6. **Implement proper loading states** - Show users when data is being loaded or saved\n7. **Use proper error boundaries** - Prevent save errors from crashing the entire editor"
      }
    ]
  } as const satisfies ComponentLayer; 