{
  "name": "UI Builder Schema Generator Utils",
  "type": "registry:lib",
  "registryDependencies": [],
  "dependencies": [
    "react-docgen-typescript",
    "ts-morph",
    "ts-to-zod"
  ],
  "devDependencies": [
    "react-docgen-typescript",
    "ts-morph",
    "ts-to-zod"
  ],
  "tailwind": {
    "config": {}
  },
  "cssVars": {},
  "files": [
    {
      "path": "lib/ui-builder/zod-gen.ts",
      "target": "src/lib/ui-builder/zod-gen.ts",
      "content": "\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { fileToDoc } from './file-to-doc';\nimport { docToInterface, PropInterfaceData } from './doc-to-interface';\nimport { interfacesToSchema } from './interfaces-to-schema';\n\n\n// NOTE: for the script to find a component, it must take props\n\n// Define directories and paths\nconst componentsDir = path.join(__dirname, '..', '..', 'components');\n\n/**\n * Recursively traverses the components directory to find and process .tsx files.\n * @param dir - The directory to traverse.\n */\nfunction generateDocs(dir: string) {\n  const files = fs.readdirSync(dir);\n  const interfaceDataArray: PropInterfaceData[] = [];\n\n  files.forEach((file) => {\n    const filePath = path.join(dir, file);\n    const stat = fs.statSync(filePath);\n\n    if (stat.isDirectory()) {\n      // Recursively process subdirectories\n      generateDocs(filePath);\n    } else if (file.endsWith('.tsx')) {\n      // Process only specific files or all .tsx files by removing the condition\n      const filesToProcess: string[] = [];\n      if (filesToProcess.length > 0 && !filesToProcess.includes(file)) {\n        return;\n      }\n\n      try {\n\n        console.log(\"Processing file:\", file);\n        // Parse the component file to extract prop types\n        const docs = fileToDoc(filePath);\n        // const fileContent = fs.readFileSync(filePath, 'utf8');\n        // const zodString = generate({sourceText: fileContent});\n        // console.log({ zodString: zodString.getZodSchemasFile(`./TempSchemas.ts`) });\n        // throw new Error(\"stop\");\n        console.log(`Found ${ docs.length } components in ${ file }`);\n        if (docs.length === 0) {\n          return;\n        }\n\n        for (const doc of docs) {\n          const interfaceData = docToInterface(doc, componentsDir, dir);\n          console.log(`Interface data for ${ doc.displayName }:\\n`, interfaceData);\n          interfaceDataArray.push(interfaceData);\n        }\n      } catch (error) {\n        console.error(`Error processing file ${ filePath }:`, error);\n      }\n    }\n  });\n\n  if (interfaceDataArray.length > 0) {\n    // Generate the consolidated schemas file\n    const dirParts = dir !== componentsDir ? path.relative(componentsDir, dir).split(path.sep) : [];\n    const schemaFileContent = interfacesToSchema(interfaceDataArray);\n    console.log({ componentsDir, dirParts });\n    const schemaPathParts: string[] = [componentsDir, ...dirParts, 'generated-schemas.ts'];\n    const schemaFilePath = path.join(...schemaPathParts);\n\n    fs.writeFileSync(schemaFilePath, schemaFileContent);\n    console.log(`Generated zod schema file: ${ schemaFilePath }`);\n  }\n}\n\n\n\n\n\n// Initiate the documentation and schema generation\ngenerateDocs(componentsDir);",
      "type": "registry:lib"
    },
    {
      "path": "lib/ui-builder/interfaces-to-schema.ts",
      "target": "src/lib/ui-builder/interfaces-to-schema.ts",
      "content": "import * as path from 'path';\nimport { generate } from 'ts-to-zod';\nimport { PropInterfaceData } from \"./doc-to-interface\";\n\n/**\n * Generates a consolidated schemas file using string templating.\n * Ensures a single import of 'zod' and handles name clashes.\n * @param docs - Array of component documentation.\n * @returns The content of the consolidated schemas file as a string.\n */\nexport function interfacesToSchema(interfaceData: PropInterfaceData[]): string {\n    // Initialize with a single import statement for zod\n    let imports = `import { z } from 'zod';\\n`;\n\n    const componentImports: string[] = [];\n    const schemaDefinitions: string[] = [];\n    const componentDefinitions: string[] = [];\n\n    // Object to keep track of import name counts for aliasing\n    const importNameCount: { [key: string]: number } = {};\n\n    const interfaceCount = interfaceData.length;\n\n    interfaceData.forEach((interfaceDataItem) => {\n        let { componentName, interfaceString, from, isDefault, filePath } = interfaceDataItem;\n\n        let isDuplicate = false;\n        const originalName = componentName;\n        // Handle name collisions by aliasing\n        if (importNameCount[componentName]) {\n            importNameCount[componentName] += 1;\n            componentName = `${componentName}${importNameCount[componentName]}`;\n            isDuplicate = true;\n        } else {\n            importNameCount[componentName] = 1;\n        }\n\n        componentImports.push(getImportStatement({isDefault, originalName, componentName, filePath, isDuplicate}));\n\n        // Generate Zod schema\n        const zodGenerator = generate({ sourceText: interfaceString });\n        let zodSchema: string;\n\n        if (zodGenerator.errors && zodGenerator.errors.length > 0) {\n            console.error(`Error generating Zod schema for ${componentName}:`, zodGenerator.errors);\n            // Use an empty Zod object schema when errors occur\n            zodSchema = 'z.object({})';\n        } else {\n            zodSchema = zodGenerator.getZodSchemasFile(`./TempSchemas.ts`);\n            // Remove the import { z } from 'zod'; from each generated schema\n            zodSchema = zodSchema.replace(/^import\\s+\\{\\s*z\\s+\\}\\s+from\\s+['\"]zod['\"];\\s*/gm, '');\n            // Remove the // Generated by ts-to-zod\n            zodSchema = zodSchema.replace(/\\/\\/ Generated by ts-to-zod\\n/, '');\n            // Remove the variable declaration of the schema like const reactFunctionComplexTypesPropsSchema =\n            zodSchema = zodSchema.replace(/^export const \\w+PropsSchema = /, '');\n\n            if (!zodSchema.trim()) {\n                console.error(`Zod schema for ${componentName} is empty after replacements.`);\n                // Fallback to empty Zod object if schema is empty\n                zodSchema = 'z.object({})';\n            } else {\n                // Handle name clashes by appending component name\n                zodSchema = `${ zodSchema.trim() }`;\n            }\n        }\n\n        // Define the schema name using the aliased component name\n        const schemaName = `${ componentName }Schema`;\n\n        schemaDefinitions.push(`\nexport const ${ schemaName } = ${ zodSchema }\n          `);\n\n        // Prepare component definition entry using the aliased component name\n        componentDefinitions.push(`\n    ${ componentName }: {\n      component: ${ componentName },\n      from: '${ from }',\n      schema: ${ schemaName }\n    },`);\n    });\n\n    imports += componentImports.join('\\n') + '\\n\\n';\n    const schemas = schemaDefinitions.join('\\n');\n    const definitions = `\nexport const ComponentDefinitions = {\n${ componentDefinitions.join('\\n') }\n};\n`;\n\n    const finalSchema = patchPartials(`${ imports }\\n${ schemas }\\n${ definitions }`);\n    console.log(`Merged ${ interfaceCount } interfaces into schema.`);\n    return finalSchema;\n}\n\n/**\n * Generates the appropriate import statement based on whether the component is a default export.\n * @param doc - The component documentation.\n * @returns The appropriate import statement.\n */\nfunction getImportStatement({isDefault, originalName, componentName, filePath, isDuplicate}:{isDefault: boolean, originalName: string, componentName: string, filePath: string, isDuplicate: boolean}): string {\n    const filenameWithoutExt = path.basename(filePath, '.tsx');\n\n    return isDefault\n        ? `import ${componentName} from './${filenameWithoutExt}';`\n        : `import { ${originalName} ${isDuplicate ? `as ${componentName} ` : ''}} from './${filenameWithoutExt}';`;\n}\n\nfunction patchPartials(schema: string) {\n    // patch partials because ts-to-zod puts them in the wrong place\n    return schema.replace(/\\.partial\\(\\)/g, \"\");\n}",
      "type": "registry:lib"
    },
    {
      "path": "lib/ui-builder/file-to-doc.ts",
      "target": "src/lib/ui-builder/file-to-doc.ts",
      "content": "import { withCustomConfig, ComponentDoc, PropItem } from 'react-docgen-typescript';\nimport { Project, SourceFile, CallExpression, Identifier, Node } from 'ts-morph';\n\nconst defaultParserOpts = {\n  savePropValueAsString: true,\n  skipChildrenPropWithoutDoc: false,\n  shouldExtractValuesFromUnion: false,\n  shouldExtractLiteralValuesFromEnum: false,\n  shouldRemoveUndefinedFromOptional: true,\n  shouldSortUnions: true,\n  customComponentTypes: [\"Toaster\"],\n  propFilter: (prop: PropItem) => {\n    if (prop.declarations && prop.declarations.length > 0) {\n      // Filter props based on declarations\n      const hasValidDeclaration = prop.declarations.some((declaration) => {\n        const isChildren = prop.name === 'children';\n        const isRadixUI = declaration.fileName.includes('@radix-ui'); // specific to shadcn/ui as components are imported from there\n        // skip node_modules for props inheriting things like HTMLDivElement, or we will get an overwhelming amount of props\n        const isNodeModules = declaration.fileName.includes('node_modules');\n\n        return isChildren || isRadixUI || !isNodeModules;\n      });\n      return hasValidDeclaration;\n    }\n    return true;\n  },\n};\n\n// Create a parser with custom configuration\nconst customParser = withCustomConfig('./tsconfig.json', defaultParserOpts);\n// const parser = withDefaultConfig(defaultParserOpts);\n\n// Extend the ComponentDoc type to include isDefault flag and componentName\nexport type ComponentDocWithIsDefault = ComponentDoc & {\n  isDefault: boolean;\n  componentName: string;\n};\n\n// Initialize a ts-morph Project\nconst project = new Project({\n  tsConfigFilePath: './tsconfig.json',\n});\n\n/**\n * Parses a file and returns the documentation along with export information.\n * @param filePath - The path to the file to parse.\n * @returns The documentation for the file including isDefault and componentName.\n */\nexport function fileToDoc(filePath: string): ComponentDocWithIsDefault[] {\n  const docs = customParser.parse(filePath);\n  const sourceFile = project.addSourceFileAtPath(filePath);\n\n  const exportNames = getExportNames(sourceFile);\n  console.log({exportNames});\n\n  return docs.map((doc) => {\n    const exportInfo = exportNames.find((exp) => {\n        // console.log({docDisplayName: doc.displayName, expDisplayName: exp.displayName, expName: exp.name, expIsDefault: exp.isDefault});\n        return exp.displayName === doc.displayName || exp.name.toLowerCase() === doc.displayName.toLowerCase();\n    });\n    const isDefault = exportInfo ? exportInfo.isDefault : false;\n    const componentName = exportInfo ? exportInfo.name : doc.displayName;\n    return { ...doc, isDefault, componentName };\n  });\n}\n\n/**\n * Retrieves export names from a source file.\n * @param sourceFile - The ts-morph SourceFile object.\n * @returns An array of Export objects containing name and isDefault flag.\n */\nfunction getExportNames(sourceFile: SourceFile): Export[] {\n    const defaultExports = sourceFile.getExportAssignments();\n    const exportSymbols = sourceFile.getExportSymbols();\n    const exportNames: Export[] = [];\n  \n    // First, collect all export names\n    defaultExports.forEach((exportAssignment) => {\n      const expr = exportAssignment.getExpression();\n      if (expr) {\n        let name: string;\n  \n        if (Node.isIdentifier(expr)) {\n          // export default Identifier;\n          name = expr.getText();\n        } else if (Node.isCallExpression(expr)) {\n          // Handle higher-order components or wrapper functions e.g., export default memo(Component);\n          const callExpr = expr as CallExpression;\n          const args = callExpr.getArguments();\n          const identifierArg = args.find((arg) => Node.isIdentifier(arg)) as Identifier | undefined;\n          name = identifierArg ? identifierArg.getText() : expr.getText();\n        } else {\n          // Fallback to the expression's text\n          name = expr.getText();\n        }\n  \n        exportNames.push({\n          name: name,\n          isDefault: true,\n        });\n      }\n    });\n  \n    exportSymbols.forEach((exportSymbol) => {\n      if (exportSymbol.getName() !== 'default') {\n        exportNames.push({\n          name: exportSymbol.getName(),\n          isDefault: false,\n        });\n      }\n    });\n  \n    // Now, map component names to their displayNames if defined\n    const displayNameMap: Record<string, string> = {};\n  \n    // Find all expression statements that assign to Component.displayName\n    sourceFile.getStatements().forEach(statement => {\n      if (Node.isExpressionStatement(statement)) {\n        const expression = statement.getExpression();\n        if (Node.isBinaryExpression(expression)) {\n          const left = expression.getLeft();\n          const right = expression.getRight();\n  \n          // Check if the left side is of the form Component.displayName\n          if (\n            Node.isPropertyAccessExpression(left) &&\n            left.getName() === 'displayName' &&\n            Node.isIdentifier(left.getExpression())\n          ) {\n            const componentName = left.getExpression().getText();\n            let displayNameValue = '';\n  \n            // Extract the displayName value if it's a string literal\n            if (Node.isStringLiteral(right) || Node.isNoSubstitutionTemplateLiteral(right)) {\n              displayNameValue = right.getLiteralText();\n            } else {\n              // Handle cases where displayName is assigned a variable or expression\n              displayNameValue = right.getText();\n            }\n  \n            displayNameMap[componentName] = displayNameValue;\n          }\n        }\n      }\n    });\n  \n    // Assign displayName to the corresponding exports\n    exportNames.forEach(exp => {\n      if (displayNameMap[exp.name]) {\n        exp.displayName = displayNameMap[exp.name];\n      }else {\n        //fallback to filename because displayName is not defined and react-docgen-typescript uses the name of the file as the displayName for default exports\n        exp.displayName = sourceFile.getBaseName().replace('.tsx', '').replace('-', '');\n      }\n    });\n  \n    return exportNames;\n  }\n\n/**\n * Represents an export from a source file.\n */\ninterface Export {\n  name: string;\n  isDefault: boolean;\n  displayName?: string;\n}",
      "type": "registry:lib"
    },
    {
      "path": "lib/ui-builder/doc-to-interface.ts",
      "target": "src/lib/ui-builder/doc-to-interface.ts",
      "content": "import * as path from 'path';\nimport { ComponentDocWithIsDefault } from \"./file-to-doc\";\nimport { Project, } from 'ts-morph';\n\n// Initialize ts-morph Project for type checking\nconst project = new Project({\n    useInMemoryFileSystem: true,\n});\n\nexport type PropInterfaceData = {\n    interfaceString: string;\n    componentName: string;\n    from: string;\n    isDefault: boolean;\n    filePath: string;\n}\n\n/**\n * Generates a TypeScript interface string for a given component.\n * Handles complex types by assigning appropriate default values.\n * @param doc - The component documentation extracted by react-docgen-typescript.\n * @returns The TypeScript interface as a string.\n */\nexport function docToInterface(doc: ComponentDocWithIsDefault, rootDir: string, dirPart: string | undefined): PropInterfaceData {\n    //log all type names in doc\n    // Object.entries(doc.props).forEach(([propName, propData]) => {\n    //     console.log({ key: propName, type: propData.type.name, declarations: propData.declarations });\n    // });\n\n    const path = dirPart ? dirPart.replace(rootDir, '') : '';\n    let interfaceString = '';\n\n    // Start interface definition\n    interfaceString += `export interface ${ doc.componentName }Props {\\n`;\n\n    Object.entries(doc.props).forEach(([propName, propData]) => {\n        // console.log({ propData });\n        const optionalFlag = propData.required ? '' : '?';\n        let propType = propData.type.name;\n\n        // Check if the type is a function\n        if (isFunctionType(propType)) {\n            console.log(`Type \"${ propType }\" identified as a function. Replacing with generic function type.`);\n            propType = '(...args: any[]) => any';\n        }\n        // Validate the prop type\n        else if (!isValidType(propType)) {\n            console.warn(`Invalid TypeScript type \"${ propType }\" for prop \"${ propName }\" in component \"${ doc.displayName }\". Defaulting to \"any\".`);\n            propType = 'any';\n        }\n\n\n        interfaceString += `  ${ fixKey(propName) }${ optionalFlag }: ${ propType };\\n`;\n    });\n\n    interfaceString += '}\\n';\n\n    const componentName = doc.componentName;\n    // const relativePath = getRelativeImportPath(doc.filePath, rootDir, dirPart);\n\n    const from = `@/components${ path }/${ getFilenameWithoutExtension(doc.filePath) }`;\n    // console.log({ from, dirPart });\n    return {\n        interfaceString,\n        componentName,\n        from,\n        isDefault: doc.isDefault,\n        filePath: doc.filePath\n    };\n}\n\n/**\n * Checks if a given type name is a valid TypeScript type without external dependencies.\n * @param typeName - The name of the type to validate.\n * @returns True if the type is valid, false otherwise.\n */\nfunction isValidType(typeName: string): boolean {\n\n    // Create a temporary source file with the type declaration\n    const sourceFile = project.createSourceFile(\"temp.ts\", `type TempType = ${ typeName };`, { overwrite: true });\n\n    // Retrieve diagnostics (errors) for the source file\n    const diagnostics = sourceFile.getPreEmitDiagnostics();\n\n    if (diagnostics.length > 0) {\n        console.warn(`Type \"${ typeName }\" is invalid:`, diagnostics.map(d => d.getMessageText()).join(\", \"));\n        return false;\n    }\n\n\n    return true;\n}\n\n/**\n * Checks if a given type name is a function type.\n * @param typeName - The name of the type to check.\n * @returns True if the type is a function, false otherwise.\n */\nfunction isFunctionType(typeName: string): boolean {\n    // Create a temporary source file with the type declaration\n    const sourceFile = project.createSourceFile(\"temp.ts\", `type TempType = ${ typeName };`, { overwrite: true });\n    const typeAlias = sourceFile.getTypeAliasOrThrow(\"TempType\");\n    const type = typeAlias.getType();\n\n    // Check if the type is a function\n    return type.getCallSignatures().length > 0;\n}\n\n/**\n * Fixes any valid key to a valid type key by adding quotes if necessary.\n * e.g., area-label -> \"area-label\"\n * @param key - String of the key to fix.\n * @returns The fixed key.\n */\nfunction fixKey(key: string): string {\n    if (key.includes('-')) {\n        return `\"${ key }\"`;\n    }\n    return key;\n}\n\n/**\n * Gets filename without the extension.\n * @param filepath - The absolute path of the component file.\n * @returns The filename without the extension.\n */\nfunction getFilenameWithoutExtension(filepath: string): string {\n    // console.log(filepath);\n    return path.basename(filepath, '.tsx');\n}\n\n",
      "type": "registry:lib"
    }
  ]
}